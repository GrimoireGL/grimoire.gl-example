!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var n=t();for(var o in n)("object"==typeof exports?exports:e)[o]=n[o]}}(this,function(){return function(e){function t(o){if(n[o])return n[o].exports;var i=n[o]={exports:{},id:o,loaded:!1};return e[o].call(i.exports,i,i.exports,t),i.loaded=!0,i.exports}var n={};return t.m=e,t.c=n,t.p="",t(0)}([function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(7),r=o(i),a=n(4),s=o(a),l=n(8),u=o(l),c=n(3),f=o(c),h=n(9),d=o(h),p=n(10),_=o(p),g=n(1),m=o(g),v=n(5),b=o(v),y=n(11),w=o(y),C=n(12),T=o(C),O=n(13),M=o(O),P=n(14),S=o(P),L=n(16),R=o(L),I="1.3.1",x="grimoirejs-forward-shading",E={Components:{DirectionalLightTypeComponent:r.default,ForwardShadingManagerComponent:s.default,LightComponent:u.default,LightTypeComponentBase:f.default,PointLightTypeComponent:d.default,RenderShadowMapComponent:_.default,SceneLightManager:m.default,ShadowMapCameraComponent:b.default,SpotLightShadowMapCameraComponent:w.default,SpotLightTypeComponent:T.default},Util:{LightVariableRegister:M.default,VectorArrayContainer:S.default}},D=(0,R.default)();Object.assign(E,{__VERSION__:I,__NAME__:x}),Object.assign(D||{},E),window.GrimoireJS.lib.forward_shading=E,t.default=D},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(15),u=o(l),c=n(21),f=o(c),h=n(24),d=o(h),p=n(6),_=o(p),g=n(4),m=o(g),v=n(23),b=o(v),y=n(2),w=o(y),C=function(e){function t(){i(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments));return e.lights={point:[],directional:[],spot:[]},e.shadowMapCameras=[],e}return a(t,e),s(t,[{key:"$awake",value:function(){var e=this;this.getAttributeRaw("shadowQuality").watch(function(t){e._singleShadowMapSize=Math.pow(2,t)},!0)}},{key:"$mount",value:function(){this._gl=this.companion.get("gl"),this._shadowMapTexture=new d.default(this._gl),this._lightMatricesTexture=new d.default(this._gl),this._lightMatricesTexture.magFilter=WebGLRenderingContext.NEAREST,this._lightMatricesTexture.minFilter=WebGLRenderingContext.NEAREST,this._shadowMapRenderbuffer=new b.default(this._gl),this._maxTextureSize=this._gl.getParameter(WebGLRenderingContext.MAX_TEXTURE_SIZE),this._shadingManager=this.node.getComponentInAncestor(m.default);var e=this.node.getComponent(_.default);this._lightSceneDesc=e.sceneDescription.lights,this._shadingManager.addSceneLightManager(this),this._updateShadowMapSize(),this.shadowMapFBO=new f.default(this._gl),this.shadowMapFBO.update(this._shadowMapTexture),this.shadowMapFBO.update(this._shadowMapRenderbuffer)}},{key:"$unmount",value:function(){this._shadingManager.removeSceneLightManager(this),this.shadowMapFBO.destroy(),this._shadowMapTexture.destroy()}},{key:"addLight",value:function(e){switch(e.lightType){case"point":this.lights.point.push(e),this._lightSceneDesc.point.colors.incrementLength(),this._lightSceneDesc.point.positions.incrementLength(),this._lightSceneDesc.point.params.incrementLength();break;case"directional":this.lights.directional.push(e),this._lightSceneDesc.directional.colors.incrementLength(),this._lightSceneDesc.directional.directions.incrementLength(),this._lightSceneDesc.directional.params.incrementLength();break;case"spot":this.lights.spot.push(e),this._lightSceneDesc.spot.colors.incrementLength(),this._lightSceneDesc.spot.directions.incrementLength(),this._lightSceneDesc.spot.positions.incrementLength(),this._lightSceneDesc.spot.params.incrementLength()}this._shadingManager.updateLightCount()}},{key:"removeLight",value:function(e){switch(e.lightType){case"point":var t=this.lights.point.indexOf(e);this.lights.point.splice(t,1),this._lightSceneDesc.point.colors.decrementLength(),this._lightSceneDesc.point.positions.decrementLength(),this._lightSceneDesc.point.params.decrementLength();break;case"directional":var n=this.lights.directional.indexOf(e);this.lights.directional.splice(n,1),this._lightSceneDesc.directional.colors.decrementLength(),this._lightSceneDesc.directional.directions.decrementLength(),this._lightSceneDesc.directional.params.decrementLength();break;case"spot":var o=this.lights.spot.indexOf(e);this.lights.spot.splice(o,1),this._lightSceneDesc.spot.colors.decrementLength(),this._lightSceneDesc.spot.directions.decrementLength(),this._lightSceneDesc.spot.positions.decrementLength(),this._lightSceneDesc.spot.params.decrementLength()}this._shadingManager.updateLightCount()}},{key:"addShadowMapCamera",value:function(e){this.shadowMapCameras.push(e),e.shadowMapIndex=this.shadowMapCameras.length-1,this._updateShadowMapSize()}},{key:"removeShadowMapCamera",value:function(e){var t=this.shadowMapCameras.indexOf(e);this.shadowMapCameras.splice(t,1);for(var n=0;n<this.shadowMapCameras.length;n++)this.shadowMapCameras[n].shadowMapIndex=n;this._updateShadowMapSize()}},{key:"viewportByShadowmapIndex",value:function(e){var t=e%this._shadowMapElementCounts.X,n=(e-t)/this._shadowMapElementCounts.X;this._gl.viewport(t*this._singleShadowMapSize,n*this._singleShadowMapSize,this._singleShadowMapSize,this._singleShadowMapSize)}},{key:"updateLightMatricies",value:function(e){var t=this;this.shadowMapCameras.forEach(function(t){t.updateCamera(e)}),this.shadowMapCameras.forEach(function(e,n){for(var o=e.ProjectionViewMatrix.rawElements,i=0;i<16;i++)t.lightMatrices[16*n+i]=o[i]}),this._updateLightMatricesTexture()}},{key:"_updateShadowMapSize",value:function(){var e=this._maxTextureSize,t=this._singleShadowMapSize,n=this.shadowMapCameras.length,o=0===n?0:Math.pow(2,Math.ceil(Math.log2(Math.ceil(Math.sqrt(n)))))*t;if(o>e)throw new Error("Max shadow map buffer size overflow");0===n?(this._shadowMapTexture.update(0,1,1,0,WebGLRenderingContext.RGB,WebGLRenderingContext.UNSIGNED_BYTE),this._shadowMapRenderbuffer.update(WebGLRenderingContext.DEPTH_COMPONENT16,1,1)):(this._shadowMapTexture.update(0,o,o,0,WebGLRenderingContext.RGB,WebGLRenderingContext.UNSIGNED_BYTE),this._shadowMapRenderbuffer.update(WebGLRenderingContext.DEPTH_COMPONENT16,o,o));var i=Math.pow(2,Math.ceil(Math.log2(n)));this.lightMatrices=new Float32Array(16*i),this._shadowMapElementCounts=new u.default(o/t,o/t),this._updateLightMatricesTexture(),this._lightSceneDesc.shadowMap={shadowMapCountPerEdge:this._shadowMapElementCounts,count:i,shadowMap:this._shadowMapTexture,lightMatrices:this._lightMatricesTexture,pixelSize:1/this._singleShadowMapSize}}},{key:"_updateLightMatricesTexture",value:function(){var e=this.shadowMapCameras.length;this._lightMatricesTexture.update(0,4,Math.pow(2,Math.ceil(Math.log2(e))),0,WebGLRenderingContext.RGBA,WebGLRenderingContext.FLOAT,this.lightMatrices)}}]),t}(w.default);t.default=C,C.attributes={shadowQuality:{converter:"Number",default:9}}},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.Node.Component},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(6),u=o(l),c=n(1),f=o(c),h=n(2),d=o(h),p=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$mount",value:function(){this.__sceneLightManager=this.node.getComponentInAncestor(f.default);var e=this.__sceneLightManager.node.getComponent(u.default).sceneDescription;this.__lightDesc=e.lights,this.__sceneLightManager.addLight(this)}},{key:"$unmount",value:function(){this.__sceneLightManager.removeLight(this)}},{key:"__ensureIndex",value:function(e){var t=e.indicies.indexOf(this.id);return t>=0?t:(e.indicies.push(this.id),e.indicies.length-1)}}]),t}(d.default);t.default=p},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(2),u=o(l),c=function(e){function t(){i(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments));return e._sceneLightManagers=[],e}return a(t,e),s(t,[{key:"$awake",value:function(){this._macroRegistry=this.companion.get("MaterialFactory").macro,this._macroRegistry.setValue("DIR_LIGHT_COUNT","0"),this._macroRegistry.setValue("POINT_LIGHT_COUNT","0"),this._macroRegistry.setValue("SPOT_LIGHT_COUNT","0"),this._macroRegistry.setValue("SHADOW_MAP_COUNT","0")}},{key:"addSceneLightManager",value:function(e){this._sceneLightManagers.push(e),this.updateLightCount()}},{key:"removeSceneLightManager",value:function(e){var t=this._sceneLightManagers.indexOf(e);this._sceneLightManagers.splice(t,1),this.updateLightCount()}},{key:"updateLightCount",value:function(){for(var e=0,t=0,n=0,o=0,i=0;i<this._sceneLightManagers.length;i++){var r=this._sceneLightManagers[i];e=Math.max(r.lights.directional.length,e),n=Math.max(r.lights.point.length,n),t=Math.max(r.lights.spot.length,t),o=Math.max(r.shadowMapCameras.length,o)}this._macroRegistry.setValue("DIR_LIGHT_COUNT",e+""),this._macroRegistry.setValue("POINT_LIGHT_COUNT",n+""),this._macroRegistry.setValue("SPOT_LIGHT_COUNT",t+""),this._macroRegistry.setValue("SHADOW_MAP_COUNT",o+"")}}]),t}(u.default);t.default=c,c.attributes={},c._typeToMacros={point:"POINT_LIGHT_COUNT",directional:"DIR_LIGHT_COUNT",spot:"SPOT_LIGHT_COUNT"}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,n);if(void 0===i){var r=Object.getPrototypeOf(t);return null===r?void 0:e(r,n,o)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(o)},u=n(27),c=o(u),f=n(28),h=o(f),d=n(1),p=o(d),_=n(17),g=o(_),m=n(26),v=o(m),b=function(e){function t(){i(this,t);var e=r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments));return e._sceneAABBCache=new v.default,e._vectorCache=new h.default(0,0,0),e}return a(t,e),s(t,[{key:"$awake",value:function(){this.Near=.01,this.Far=50,this.OrthographicMode=!0,this.OrthoSize=30,this.AutoAspect=!1,this.Aspect=1}},{key:"$mount",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"$mount",this).call(this);var e=this.containedScene.node.getComponent(p.default);e.addShadowMapCamera(this)}},{key:"updateCamera",value:function(e){this._sceneAABBCache.clear();for(var t=c.default.inverse(e.ProjectionViewMatrix),n=0;n<2;n++)for(var o=0;o<2;o++)for(var i=0;i<2;i++)this._vectorCache.rawElements[0]=0==n?-1:1,this._vectorCache.rawElements[1]=0==o?-1:1,this._vectorCache.rawElements[2]=0==i?-1:1,this._sceneAABBCache.expand(c.default.transformPoint(t,this._vectorCache));this._sceneAABBCache.pointLBF.subtractWith(this._sceneAABBCache.Center).magnitude}},{key:"$unmount",value:function(){var e=this.containedScene.node.getComponent(p.default);e.removeShadowMapCamera(this)}}]),t}(g.default);t.default=b},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Components.SceneComponent},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(3),u=o(l),c=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$awake",value:function(){var e=this;this.lightType="directional",this.getAttributeRaw("color").boundTo("_color"),this.getAttributeRaw("intensity").boundTo("_intensity"),this.getAttributeRaw("shadow").watch(function(t){return e._useShadowChanged(t)},!0),this._transform=this.node.getComponent("Transform")}},{key:"$update",value:function(e){var t=e.lights.directional,n=this.__ensureIndex(t),o=this._transform.forward,i=this._transform.globalPosition;t.directions.set(n,o.X,o.Y,o.Z);var r=this._color;t.colors.set(n,r.R*this._intensity,r.G*this._intensity,r.B*this._intensity),t.params.set(n,this._shadowCamera?this._shadowCamera.shadowMapIndex:-1,i.X,i.Y,i.Z)}},{key:"_useShadowChanged",value:function(e){!e&&this._shadowCamera?(this._shadowCamera.dispose(),this._shadowCamera=null):e&&(this._shadowCamera=this.node.addComponent("ShadowMapCamera"))}}]),t}(u.default);t.default=c,c.attributes={color:{converter:"Color3",default:"white"},intensity:{converter:"Number",default:1},shadow:{converter:"Boolean",default:!1}}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(2),u=o(l),c=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$awake",value:function(){var e=this;this.getAttributeRaw("type").watch(function(t){return e._onLightTypeChanged(t)},!0)}},{key:"_onLightTypeChanged",value:function(e){e=e.toLowerCase(),e!==this._lastLightType&&(this._lastLightType=e,this._removeLastTypeComponent(),this._addLightTypeComponent(e))}},{key:"_addLightTypeComponent",value:function(e){switch(e){case"directional":this._lightTypeComponent=this.node.addComponent("DirectionalLightType",{},!0);break;case"point":this._lightTypeComponent=this.node.addComponent("PointLightType",{},!0);break;case"spot":this._lightTypeComponent=this.node.addComponent("SpotLightType",{},!0)}}},{key:"_removeLastTypeComponent",value:function(){this._lightTypeComponent&&this._lightTypeComponent.dispose()}}]),t}(u.default);t.default=c,c.attributes={type:{converter:"String",default:"Directional"}}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(3),u=o(l),c=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$awake",value:function(){this.lightType="point",this.getAttributeRaw("color").boundTo("_color"),this._transform=this.node.getComponent("Transform"),this.getAttributeRaw("distance").boundTo("_distance"),this.getAttributeRaw("decay").boundTo("_decay"),this.getAttributeRaw("intensity").boundTo("_intensity")}},{key:"$update",value:function(e){var t=e.lights.point,n=this.__ensureIndex(t),o=this._transform.globalPosition;t.positions.set(n,o.X,o.Y,o.Z),t.colors.set(n,this._color.R*this._intensity,this._color.G*this._intensity,this._color.B*this._intensity),t.params.set(n,this._distance,this._decay)}}]),t}(u.default);t.default=c,c.attributes={color:{converter:"Color3",default:"white"},distance:{converter:"Number",default:5},decay:{converter:"Number",default:2},intensity:{converter:"Number",default:1}}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(1),u=o(l),c=n(2),f=o(c),h=n(18),d=o(h),p=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$mount",value:function(){if(this._renderSceneComponent=this.node.getComponent(d.default),!this._renderSceneComponent)throw new Error("There was no RenderScene component found on the node attached RenderShadowMapComponent");this._gl=this.companion.get("gl")}},{key:"$render",value:function(e){var t=this,n=e.camera?e.camera:this._renderSceneComponent.camera,o=n.containedScene.node.getComponent(u.default);0!==o.shadowMapCameras.length&&(o.shadowMapFBO.bind(),this._gl.clearColor(0,0,0,0),this._gl.clearDepth(1),this._gl.clear(WebGLRenderingContext.COLOR_BUFFER_BIT|WebGLRenderingContext.DEPTH_BUFFER_BIT),o.updateLightMatricies(n),o.shadowMapCameras.forEach(function(n){o.viewportByShadowmapIndex(n.shadowMapIndex),n.updateContainedScene(e.loopIndex),n.renderScene({camera:n,buffers:null,layer:"default",viewport:e.viewport,loopIndex:e.loopIndex,technique:"depth",renderer:t._renderSceneComponent})}),this._gl.flush(),this._gl.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER,null))}}]),t}(f.default);t.default=p,p.attributes={}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=function e(t,n,o){null===t&&(t=Function.prototype);var i=Object.getOwnPropertyDescriptor(t,n);if(void 0===i){var r=Object.getPrototypeOf(t);return null===r?void 0:e(r,n,o)}if("value"in i)return i.value;var a=i.get;if(void 0!==a)return a.call(o)},u=n(5),c=o(u),f=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$awake",value:function(){l(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"$awake",this).call(this),this.OrthographicMode=!1}}]),t}(c.default);t.default=f},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),l=n(3),u=o(l),c=function(e){function t(){return i(this,t),r(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),s(t,[{key:"$awake",value:function(){var e=this;this.lightType="spot",this.getAttributeRaw("color").boundTo("_color"),this._transform=this.node.getComponent("Transform"),this.getAttributeRaw("innerCone").boundTo("_innerCone"),this.getAttributeRaw("outerCone").boundTo("_outerCone"),this.getAttributeRaw("decay").boundTo("_decay"),this.getAttributeRaw("intensity").boundTo("_intensity"),this.getAttributeRaw("shadow").watch(function(t){return e._useShadowChanged(t)},!0)}},{key:"$update",value:function(e){var t=e.lights.spot,n=this.__ensureIndex(t),o=this._transform.globalPosition,i=this._transform.up.negateThis();t.positions.set(n,o.X,o.Y,o.Z),t.colors.set(n,this._color.R*this._intensity,this._color.G*this._intensity,this._color.B*this._intensity),t.directions.set(n,i.X,i.Y,i.Z),t.params.set(n,this._innerCone,this._outerCone,this._decay,this._shadowCamera?this._shadowCamera.shadowMapIndex:-1)}},{key:"_useShadowChanged",value:function(e){!e&&this._shadowCamera?(this._shadowCamera.dispose(),this._shadowCamera=null):e&&(this._shadowCamera=this.node.addComponent("SpotLightShadowMapCamera"))}}]),t}(u.default);t.default=c,c.attributes={color:{converter:"Color3",default:"white"},innerCone:{converter:"Angle2D",default:"5d"},outerCone:{converter:"Angle2D",default:"20d"},decay:{converter:"Number",default:1},intensity:{converter:"Number",default:1},shadow:{converter:"Boolean",default:!1}}},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),a=n(19),s=o(a),l=n(25),u=o(l),c=n(20),f=o(c),h=n(31),d=o(h),p=n(30),_=o(p),g=function(){function e(){i(this,e)}return r(e,null,[{key:"registerAll",value:function(){u.default.staticImports["forward-shading"]=d.default,s.default.addSORTMaterial("basic",_.default),this._registerLightVariable("DIRECTIONAL_LIGHT_DIRECTIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.directional.directions.elements)}),this._registerLightVariable("DIRECTIONAL_LIGHT_COLORS",function(e,t,n){return t.uniformVector3Array(e,n.lights.directional.colors.elements)}),this._registerLightVariable("DIRECTIONAL_LIGHT_PARAMS",function(e,t,n){return t.uniformVector4Array(e,n.lights.directional.params.elements)}),this._registerLightVariable("POINT_LIGHT_POSITIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.point.positions.elements)}),this._registerLightVariable("POINT_LIGHT_COLORS",function(e,t,n){return t.uniformVector3Array(e,n.lights.point.colors.elements)}),this._registerLightVariable("POINT_LIGHT_PARAMS",function(e,t,n){return t.uniformVector2Array(e,n.lights.point.params.elements)}),this._registerLightVariable("SPOT_LIGHT_POSITIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.spot.positions.elements)}),this._registerLightVariable("SPOT_LIGHT_COLORS",function(e,t,n){return t.uniformVector3Array(e,n.lights.spot.colors.elements)}),this._registerLightVariable("SPOT_LIGHT_DIRECTIONS",function(e,t,n){return t.uniformVector3Array(e,n.lights.spot.directions.elements)}),this._registerLightVariable("SPOT_LIGHT_PARAMS",function(e,t,n){return t.uniformVector4Array(e,n.lights.spot.params.elements)}),this._registerLightVariable("SHADOW_MATRICES",function(e,t,n){return t.uniformTexture2D(e,n.lights.shadowMap.lightMatrices)}),this._registerLightVariable("SHADOW_MATRICES_COUNT",function(e,t,n){return t.uniformFloat(e,n.lights.shadowMap.count)}),this._registerLightVariable("SHADOW_MAP_TEXTURE",function(e,t,n){return t.uniformTexture2D(e,n.lights.shadowMap.shadowMap)}),this._registerLightVariable("SHADOW_MAP_ELEMENT_COUNT",function(e,t,n){return t.uniformVector2(e,n.lights.shadowMap.shadowMapCountPerEdge)}),this._registerLightVariable("SHADOW_MAP_PIXEL_SIZE",function(e,t,n){return t.uniformFloat(e,n.lights.shadowMap.pixelSize)})}},{key:"_registerLightVariable",value:function(e,t){f.default.add(e,function(e){return function(n,o){t(e.name,n,o.sceneDescription)}})}}]),e}();t.default=g},function(e,t){"use strict";function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),i=function(){function e(t,o){n(this,e),this.size=t,this.length=o,this.resize(t,o)}return o(e,[{key:"resize",value:function(e,t){this.elements=new Float32Array(e*t),this.size=e,this.length=t}},{key:"set",value:function(e,t,n,o,i){var r=this.size*e;this.elements[r+0]=t,void 0!==n&&(this.elements[r+1]=n,void 0!==o&&(this.elements[r+2]=o,void 0!==i&&(this.elements[r+3]=i)))}},{key:"incrementLength",value:function(){this.resize(this.size,this.length+1)}},{key:"decrementLength",value:function(){this.resize(this.size,this.length-1)}}]),e}();t.default=i},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.Vector2},function(e,t,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var i=n(11),r=o(i),a=n(15),s=o(a),l=n(10),u=o(l),c=n(5),f=o(c),h=n(14),d=o(h),p=n(1),_=o(p),g=n(7),m=o(g),v=n(8),b=o(v),y=n(9),w=o(y),C=n(12),T=o(C),O=n(4),M=o(O),P=n(29),S=o(P),L=n(22),R=o(L),I=n(13),x=o(I),E=n(6),D=o(E),N=function(e,t,n,o){return new(n||(n=Promise))(function(i,r){function a(e){try{l(o.next(e))}catch(e){r(e)}}function s(e){try{l(o.throw(e))}catch(e){r(e)}}function l(e){e.done?i(e.value):new n(function(t){t(e.value)}).then(a,s)}l((o=o.apply(e,t||[])).next())})};t.default=function(){S.default.register(function(){return N(void 0,void 0,void 0,regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:D.default.onSceneDescriptionCreation(function(e){e.lights={directional:{indicies:[],directions:new d.default(3,0),colors:new d.default(3,0),params:new d.default(4,0)},point:{indicies:[],positions:new d.default(3,0),colors:new d.default(3,0),params:new d.default(2,0)},spot:{indicies:[],positions:new d.default(3,0),directions:new d.default(3,0),colors:new d.default(3,0),params:new d.default(4,0)},shadowMap:{shadowMapCountPerEdge:new s.default(0,0),shadowMap:null,lightMatrices:null,pixelSize:0,count:0}}}),t=S.default,t.registerComponent("ForwardShadingManager",M.default),t.registerComponent("Light",b.default),t.registerComponent("DirectionalLightType",m.default),t.registerComponent("PointLightType",w.default),t.registerComponent("SpotLightType",T.default),
t.registerComponent("SceneLightManager",_.default),t.registerComponent("ShadowMapCamera",f.default),t.registerComponent("RenderShadowMap",u.default),t.registerComponent("SpotLightShadowMapCamera",r.default),t.overrideDeclaration("scene",["SceneLightManager"]),t.overrideDeclaration("render-scene",["RenderShadowMap"]),t.nodeDeclarations.get("goml").defaultComponents.push(t.ns("http://grimoire.gl/ns/default")("ForwardShadingManager")),t.componentDeclarations.get("MaterialContainer").attributes.material.default="new(basic)",t.registerNode("light",["Transform","Light"]),x.default.registerAll(),R.default.request("OES_texture_float");case 18:case"end":return e.stop()}},e,this)}))})}},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Components.CameraComponent},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Components.RenderSceneComponent},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Material.MaterialFactory},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Material.UniformResolverRegistry},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.FrameBuffer},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.GLExtRequestor},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.RenderBuffer},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Resource.Texture2D},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.fundamental.Sort.ImportResolver},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.AABB},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.Matrix},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS.lib.math.Vector3},function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=window.GrimoireJS},function(e,t){e.exports='@Technique default{\n@Pass{\n@BlendFunc(SRC_ALPHA,ONE_MINUS_SRC_ALPHA)\nFS_PREC(mediump,float)\n\nvarying vec3 vNormal;\nvarying vec2 vTexCoord;\nvarying vec4 vPosition;\n\n#ifdef VS\n  attribute vec3 position;\n  attribute vec3 normal;\n  attribute vec2 texCoord;\n\n  uniform mat4 _matPVM;\n  uniform mat4 _matM;\n\n  void main(){\n    gl_Position = _matPVM * vec4(position,1.0);\n    vNormal = normalize((_matM * vec4(normal,0.0)).xyz);\n    vPosition = (_matM * vec4(position,1.0));\n    vTexCoord = texCoord;\n  }\n#endif\n\n#ifdef FS\n  @CAMERA_POSITION\n  uniform vec3 _cameraPosition;\n\n  uniform sampler2D texture;\n\n  @HAS_TEXTURE{sampler:"texture"}\n  uniform bool useTexture;\n\n  uniform sampler2D roughnessMap;\n\n  @HAS_TEXTURE{sampler:"roughnessMap"}\n  uniform bool useRoughnessMap;\n\n  @{default:"white",type:"color"}\n  uniform vec4 albedo;\n\n  @{default:0.1}\n  uniform float roughness;\n\n  @{default:0.99}\n  uniform float refractive;\n\n  @{default:"black",type:"color"}\n  uniform vec3 emission;\n\n  @{default:0.3}\n  uniform float kCoeff;\n\n  @import "forward-shading"\n\n  void main(){\n    vec4 lastColor = vec4(0,0,0,albedo.a);\n    vec3 dBaseColor = albedo.rgb;\n    if(useTexture){\n      vec4 texColor = texture2D(texture,vTexCoord);\n      dBaseColor = pow(texColor.rgb,vec3(2.2));\n      lastColor.a = texColor.a;\n    }\n    float r = roughness;\n    if(useRoughnessMap){\n      r = texture2D(roughnessMap,vTexCoord).r;\n    }\n    lastColor.rgb += emission + shading(dBaseColor,vNormal,vPosition.xyz/vPosition.w,r);\n    gl_FragColor = lastColor;\n    gl_FragColor.rgb = pow(gl_FragColor.rgb,vec3(1.0/2.2)); // Gamma correction\n    gl_FragColor.a = lastColor.a;\n  }\n#endif\n}\n}\n\n@Technique hitarea{\n  @Disable(BLEND)\n  @Pass{\n    FS_PREC(mediump,float)\n\n    #ifdef VS\n      attribute vec3 position;\n      uniform mat4 _matPVM;\n\n      void main(){\n        gl_Position = _matPVM * vec4(position,1.0);\n      }\n    #endif\n\n    #ifdef FS\n      @MESH_INDEX\n      uniform vec4 meshIndex;\n      void main(){\n        gl_FragColor = meshIndex;\n      }\n    #endif\n  }\n}\n\n@Technique depth{\n  @Pass{\n    @CullFace(FRONT)\n  FS_PREC(highp,float)\n\n  varying vec4 vPos;\n\n  vec3 EncodeFloatRGB( float v ) {\n    vec3 enc = vec3(1.0, 255.0, 65025.0) * v;\n    enc = fract(enc);\n    enc -= enc.yzz * vec3(1.0/255.0,1.0/255.0,0.0);\n    return enc;\n  }\n\n  float DecodeFloatRGB( vec3 rgb ) {\n    return dot( rgb, vec3(1.0, 1./255.0, 1./65025.0) );\n  }\n\n  #ifdef VS\n    attribute vec3 position;\n    uniform mat4 _matPVM;\n    void main(){\n      gl_Position = vPos= _matPVM * vec4(position,1.0);\n    }\n  #endif\n\n  #ifdef FS\n    void main(){\n      gl_FragColor.rgb = EncodeFloatRGB((vPos.z/vPos.w + 1.0)/2.0);\n      gl_FragColor.a = 1.0;\n    }\n  #endif\n  }\n}\n'},function(e,t){e.exports="@ReferMacro(DIR_LIGHT_COUNT,0)\n@ReferMacro(POINT_LIGHT_COUNT,0)\n@ReferMacro(SPOT_LIGHT_COUNT,0)\n@ReferMacro(SHADOW_MAP_COUNT,0)\n@ReferMacro(OES_TEXTURE_FLOAT,)\n\n#if DIR_LIGHT_COUNT > 0\n  #define USE_DIR_LIGHT\n#endif\n\n#if POINT_LIGHT_COUNT > 0\n  #define USE_POINT_LIGHT\n#endif\n\n#if SPOT_LIGHT_COUNT > 0\n  #define USE_SPOT_LIGHT\n#endif\n\n#if SHADOW_MAP_COUNT > 0\n  #define USE_SHADOW_MAP\n#endif\n\n#ifdef USE_DIR_LIGHT\n  @DIRECTIONAL_LIGHT_DIRECTIONS\n  uniform vec3 _dLightDir[DIR_LIGHT_COUNT];\n\n  @DIRECTIONAL_LIGHT_COLORS\n  uniform vec3 _dLightColor[DIR_LIGHT_COUNT];\n\n  @DIRECTIONAL_LIGHT_PARAMS\n  uniform vec4 _dLightParams[DIR_LIGHT_COUNT];\n#endif\n\n#ifdef USE_POINT_LIGHT\n\n  @POINT_LIGHT_POSITIONS\n  uniform vec3 _pLightPosition[POINT_LIGHT_COUNT];\n\n  @POINT_LIGHT_COLORS\n  uniform vec3 _pLightColor[POINT_LIGHT_COUNT];\n\n  @POINT_LIGHT_PARAMS\n  uniform vec2 _pLightParam[POINT_LIGHT_COUNT];\n\n#endif\n\n#ifdef USE_SPOT_LIGHT\n\n  @SPOT_LIGHT_POSITIONS\n  uniform vec3 _sLightPosition[POINT_LIGHT_COUNT];\n\n  @SPOT_LIGHT_DIRECTIONS\n  uniform vec3 _sLightDir[POINT_LIGHT_COUNT];\n\n  @SPOT_LIGHT_COLORS\n  uniform vec3 _sLightColor[POINT_LIGHT_COUNT];\n\n  @SPOT_LIGHT_PARAMS\n  uniform vec4 _sLightParam[POINT_LIGHT_COUNT];\n#endif\n\n#ifdef USE_SHADOW_MAP\n  @SHADOW_MAP_ELEMENT_COUNT\n  uniform vec2 _shadowMapElementCount;\n\n  @SHADOW_MAP_PIXEL_SIZE\n  uniform float _shadowMapPixelSize;\n\n  @SHADOW_MATRICES\n  uniform sampler2D _lightMatrices;\n\n  @SHADOW_MATRICES_COUNT\n  uniform float _lightMatricesCount;\n\n  @SHADOW_MAP_TEXTURE\n  uniform sampler2D _shadowMapTexture;\n\n  @{default:0.01}\n  uniform float shadowBias;\n\n  highp float decodeFloatRGB( vec3 rgb ) {\n    return dot( rgb, vec3(1.0, 1./255.0, 1./65025.0) );\n  }\n#endif\n\n  float lambert(vec3 lightDirection,vec3 surfaceNormal) {\n    return max(0.0, dot(lightDirection, surfaceNormal));\n  }\n\n  #ifndef DIFFUSE_BRDF\n    #define DIFFUSE_BRDF lambertBRDF\n\n    vec3 lambertBRDF(vec3 c,vec3 i,vec3 o,vec3 n,float roughness){\n      return c / PI;\n    }\n  #endif\n\n  #ifndef SPECULAR_BRDF\n    #define SPECULAR_BRDF cookTorranceBRDF\n\n    #ifndef CT_D\n      #define CT_D ctd_GGX_Distribution\n    #endif\n\n    #ifndef CT_F\n      #define CT_F ctf_Schlick\n    #endif\n\n    #ifndef CT_G\n      #define CT_G ctg_GGX_GeometryTerm\n    #endif\n\n    float ctd_GGX_Distribution(vec3 l,vec3 v,vec3 n,vec3 h,float roughness){\n      float alpha2 = pow(roughness,4.0);\n      float nh2 = pow(dot(n,h),2.0);\n      return alpha2/(PI*pow(nh2*(alpha2 - 1.0) + 1.0,2.0));\n    }\n\n    float ctg_GGX_GeometryTerm(vec3 l,vec3 v,vec3 n,vec3 h,float roughness){\n      float k = pow(roughness + 1.0,2.0)/8.0;\n      float ln = dot(l,n);\n      float vn = dot(v,n);\n      return (ln/(ln*(1.-k) + k))*(vn/(vn*(1.-k) + k));\n    }\n\n    float ctf_Schlick(vec3 l,vec3 v,vec3 n,vec3 h,float roughness){\n      float f0 = refractive;\n      float vh = dot(v,h);\n      return f0 + pow(1.0-vh,5.0) * (1.0 - f0);\n    }\n\n    vec3 cookTorranceBRDF(vec3 l,vec3 v,vec3 n,float r){\n      vec3 h = normalize(l+v);\n      return vec3(CT_D(l,v,n,h,r) * CT_F(l,v,n,h,r) * CT_G(l,v,n,h,r)/(4.0 * dot(l,n) * dot(v,n)));\n    }\n  #endif\n\n  #ifndef PBR_BRDF\n    #define PBR_BRDF pbrBRDF\n    vec3 pbrBRDF(vec3 c,vec3 i,vec3 o,vec3 n,float r){\n      float k0 = kCoeff;\n      return DIFFUSE_BRDF(c,i,o,n,r) * k0 + SPECULAR_BRDF(i,o,n,r) * (1.0 - k0);\n    }\n  #endif\n#ifdef USE_DIR_LIGHT\n\n#ifdef USE_SHADOW_MAP\n\nuniform float smT;\n  bool isUVRegion(vec2 uv){\n    return all(bvec4(greaterThan(uv,vec2(0,0)),lessThan(uv,vec2(1,1))));\n  }\n\n  vec2 correctUV(vec2 uv,float index){\n    float i = fract(index / _shadowMapElementCount.x) * _shadowMapElementCount.x;\n    float j = (index - i) / _shadowMapElementCount.x;\n    return vec2((i + uv.x)/_shadowMapElementCount.x,(j + uv.y)/_shadowMapElementCount.y);\n  }\n\n  float shadowCoefficient(vec3 fragPosition,highp mat4 lightMatrix,float index){\n    highp vec4 lPos = lightMatrix * vec4(fragPosition,1.0);\n    if(any(bvec2(lPos.z/lPos.w > 1.0,lPos.z/lPos.w < -1.0))){\n      return 1.0;\n    }\n    vec2 bUV = lPos.xy / lPos.w / 2.0 + vec2(0.5);\n    highp float od = (lPos.z/lPos.w + 1.0)/2.0;\n    float fill = 0.0;\n    float N = 0.;\n    // PCF sampling\n    vec2 lUV = bUV;\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(_shadowMapPixelSize,0);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(-_shadowMapPixelSize,0);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(0,_shadowMapPixelSize);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    lUV = bUV + vec2(0,-_shadowMapPixelSize);\n    if(isUVRegion(lUV)){\n      highp float d = decodeFloatRGB(texture2D(_shadowMapTexture,correctUV(lUV,index)).rgb);\n      fill += step(shadowBias,od-d);\n      N++;\n    }\n    if(N > 4.0){\n      return 1.0 - fill/N;\n    }\n    return 1.0;\n  }\n\n  highp vec4 fromLightMatrices(vec2 uv){\n    return texture2D(_lightMatrices,uv);\n  }\n\n  highp mat4 fetchLightMatrix(float index){\n    float y = 1.0 / _lightMatricesCount * (index  + 0.5);\n    return mat4(\n      fromLightMatrices(vec2(0.125,y)),\n      fromLightMatrices(vec2(0.375,y)),\n      fromLightMatrices(vec2(0.625,y)),\n      fromLightMatrices(vec2(0.875,y))\n      );\n  }\n#endif\n\n  vec3 directionalLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){\n    vec3 result = vec3(0,0,0);\n    for(int i = 0; i < DIR_LIGHT_COUNT;i++){\n      vec3 lI = lambert(fragNormal,-_dLightDir[i]) * _dLightColor[i];\n      float sc = 1.0;\n      #ifdef USE_SHADOW_MAP // Shadowmap Calculations\n        if(_dLightParams[i].x >= 0.0){\n          highp mat4 lMat = fetchLightMatrix(_dLightParams[i].x);\n          sc = shadowCoefficient(fragPosition,lMat,_dLightParams[i].x);\n          // highp vec4 lp = lMat * vec4(fragPosition,1.0);\n          // vec2 ouv = lp.xy / 2.0 + vec2(0.5);\n          // if(isUVRegion(ouv)){\n          //   return texture2D(_shadowMapTexture,correctUV(ouv,1.0)).rgb;\n          // }\n        }\n      #endif\n      vec3 lColor = sc * lI * PBR_BRDF(baseColor,-_dLightDir[i],normalize(_cameraPosition - fragPosition),fragNormal,roughness);\n      result += lColor;\n    }\n    return result;\n  }\n#endif\n#ifdef USE_POINT_LIGHT\n  vec3 pointLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){\n    vec3 result = vec3(0,0,0);\n    for(int i = 0; i < POINT_LIGHT_COUNT;i++){\n      vec3 l2p = _pLightPosition[i] - fragPosition;\n      float d = length(l2p);\n      vec2 param = _pLightParam[i];\n      float atten = max(0.,1.0-d/param.x)/(1.0 + param.y*param.y*d);\n      l2p = normalize(l2p);\n      vec3 lI = lambert(fragNormal,l2p)* _pLightColor[i] * atten;\n      vec3 lColor = lI  * PBR_BRDF(baseColor,l2p,normalize(_cameraPosition - fragPosition),fragNormal,roughness);\n      result += lColor ;\n    }\n    return result;\n  }\n#endif\n#ifdef USE_SPOT_LIGHT\n  vec3 spotLight(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){\n    vec3 result = vec3(0);\n    for(int i = 0; i < SPOT_LIGHT_COUNT; i++){\n      float innerConeAngle = _sLightParam[i].x;\n      float outerConeAngle = _sLightParam[i].y;\n      float outCos=cos(outerConeAngle);\n      float innCos=cos(innerConeAngle);\n\n      vec3 p2l = _sLightPosition[i] - fragPosition;\n      float d = length(p2l);\n      p2l=p2l/d;\n      float c = dot(-p2l,normalize(_sLightDir[i]));\n      float decay = _sLightParam[i].z;//減衰係数\n      decay = 1.;\n      float angleDecay = decay;\n      //\n      float distDecayCoefficient = 1.0 / (d * d);\n      float angleDecayCoefficient = pow(clamp((c-outCos)/(innCos-outCos),0.0,1.0),angleDecay);\n      //\n      vec3 lI = lambert(p2l,fragNormal)*_sLightColor[i]*angleDecayCoefficient*distDecayCoefficient;\n      vec3 lColor = lI * PBR_BRDF(baseColor,p2l,normalize(_cameraPosition - fragPosition),fragNormal,roughness);\n      result += lColor;\n    }\n    return result;\n  }\n#endif\n  vec3 shading(vec3 baseColor,vec3 fragNormal,vec3 fragPosition,float roughness){\n    vec3 lightingColor = vec3(0);\n    #ifdef USE_DIR_LIGHT\n    lightingColor.rgb += directionalLight(baseColor,fragNormal,fragPosition,roughness);\n    #endif\n    #ifdef USE_POINT_LIGHT\n    lightingColor.rgb += pointLight(baseColor,fragNormal,fragPosition,roughness);\n    #endif\n    #ifdef USE_SPOT_LIGHT\n    lightingColor.rgb += spotLight(baseColor,fragNormal,fragPosition,roughness);\n    #endif\n    return lightingColor;\n  }\n"}])});
//# sourceMappingURL=grimoire-forward-shading.min.js.map